diff --git a/CRM/Api4/Page/AJAX.php b/CRM/Api4/Page/AJAX.php
index 0aa40e94d9c..638d547624f 100644
--- a/CRM/Api4/Page/AJAX.php
+++ b/CRM/Api4/Page/AJAX.php
@@ -40,7 +40,8 @@ public function run() {
       CRM_Utils_System::civiExit();
     }
     if ($_SERVER['REQUEST_METHOD'] == 'GET' &&
-      strtolower(substr($this->urlPath[4], 0, 3)) != 'get') {
+      ($this->urlPath[4] !== 'autocomplete' && strtolower(substr($this->urlPath[4], 0, 3)) !== 'get')
+    ) {
       $response = [
         'error_code' => 400,
         'error_message' => "SECURITY: All requests that modify the database must be http POST, not GET.",
diff --git a/CRM/Contact/DAO/Contact.php b/CRM/Contact/DAO/Contact.php
index 790dce543b5..6126910bbe5 100644
--- a/CRM/Contact/DAO/Contact.php
+++ b/CRM/Contact/DAO/Contact.php
@@ -6,7 +6,7 @@
  *
  * Generated from xml/schema/CRM/Contact/Contact.xml
  * DO NOT EDIT.  Generated by CRM_Core_CodeGen
- * (GenCodeChecksum:6c4b31481898fef1b087265d096c65f6)
+ * (GenCodeChecksum:1a988e976c3347c4050d0b6aad955a09)
  */
 
 /**
@@ -602,6 +602,7 @@ public static function &fields() {
             'table' => 'civicrm_contact_type',
             'keyColumn' => 'name',
             'labelColumn' => 'label',
+            'iconColumn' => 'icon',
             'condition' => 'parent_id IS NULL',
           ],
           'readonly' => TRUE,
@@ -630,6 +631,7 @@ public static function &fields() {
             'table' => 'civicrm_contact_type',
             'keyColumn' => 'name',
             'labelColumn' => 'label',
+            'iconColumn' => 'icon',
             'condition' => 'parent_id IS NOT NULL',
           ],
           'add' => '1.5',
diff --git a/CRM/Core/BAO/CustomGroup.php b/CRM/Core/BAO/CustomGroup.php
index 3b6e9269cf8..f7c1c6d1af6 100644
--- a/CRM/Core/BAO/CustomGroup.php
+++ b/CRM/Core/BAO/CustomGroup.php
@@ -2473,7 +2473,7 @@ public static function getCustomGroupExtendsOptions() {
       [
         'id' => 'Pledge',
         'label' => ts('Pledges'),
-        'grouping' => 'TODO',
+        'grouping' => NULL,
         'table_name' => 'civicrm_pledge',
       ],
       [
diff --git a/CRM/Core/CodeGen/Specification.php b/CRM/Core/CodeGen/Specification.php
index 719db4ee524..a7ba04dbe80 100644
--- a/CRM/Core/CodeGen/Specification.php
+++ b/CRM/Core/CodeGen/Specification.php
@@ -447,6 +447,9 @@ public function getField(&$fieldXML, &$fields) {
         'nameColumn',
         // Column to fetch in "abbreviate" context
         'abbrColumn',
+        // Supported by APIv4 suffixes
+        'colorColumn',
+        'iconColumn',
         // Where clause snippet (will be joined to the rest of the query with AND operator)
         'condition',
         // callback function incase of static arrays
diff --git a/Civi/Api4/Activity.php b/Civi/Api4/Activity.php
index 2de02dceed4..30925b1a3df 100644
--- a/Civi/Api4/Activity.php
+++ b/Civi/Api4/Activity.php
@@ -24,6 +24,7 @@
  * @see https://docs.civicrm.org/user/en/latest/organising-your-data/activities/
  * @searchable primary
  * @since 5.19
+ * @iconField activity_type_id:icon
  * @package Civi\Api4
  */
 class Activity extends Generic\DAOEntity {
diff --git a/Civi/Api4/Contact.php b/Civi/Api4/Contact.php
index cd717f128c3..4d1691d4d79 100644
--- a/Civi/Api4/Contact.php
+++ b/Civi/Api4/Contact.php
@@ -21,6 +21,7 @@
  * @see https://docs.civicrm.org/user/en/latest/organising-your-data/contacts/
  * @searchable primary
  * @orderBy sort_name
+ * @iconField contact_sub_type:icon,contact_type:icon
  * @since 5.19
  * @package Civi\Api4
  */
diff --git a/Civi/Api4/Entity.php b/Civi/Api4/Entity.php
index a53248cf3ac..6b84d73b9ce 100644
--- a/Civi/Api4/Entity.php
+++ b/Civi/Api4/Entity.php
@@ -72,6 +72,11 @@ class Entity extends Generic\AbstractEntity {
       'name' => 'label_field',
       'description' => 'Field to show when displaying a record',
     ],
+    [
+      'name' => 'icon_field',
+      'data_type' => 'Array',
+      'description' => 'Field(s) which contain the icon for a record, listed in order of precedence',
+    ],
     [
       'name' => 'order_by',
       'description' => 'Default column to sort results',
diff --git a/Civi/Api4/Generic/AbstractEntity.php b/Civi/Api4/Generic/AbstractEntity.php
index bc99c02a412..083e3359e2c 100644
--- a/Civi/Api4/Generic/AbstractEntity.php
+++ b/Civi/Api4/Generic/AbstractEntity.php
@@ -154,6 +154,7 @@ public static function getInfo() {
       $info['label_field'] = $dao::$_labelField;
       $info['dao'] = $dao;
       $info['table_name'] = $dao::$_tableName;
+      $info['icon_field'] = (array) ($dao::fields()['icon']['name'] ?? NULL);
     }
     foreach (ReflectionUtils::getTraits(static::class) as $trait) {
       $info['type'][] = self::stripNamespace($trait);
diff --git a/Civi/Api4/Generic/AutocompleteAction.php b/Civi/Api4/Generic/AutocompleteAction.php
new file mode 100644
index 00000000000..bb686d2bb79
--- /dev/null
+++ b/Civi/Api4/Generic/AutocompleteAction.php
@@ -0,0 +1,224 @@
+<?php
+
+/*
+ +--------------------------------------------------------------------+
+ | Copyright CiviCRM LLC. All rights reserved.                        |
+ |                                                                    |
+ | This work is published under the GNU AGPLv3 license with some      |
+ | permitted exceptions and without any warranty. For full license    |
+ | and copyright information, see https://civicrm.org/licensing       |
+ +--------------------------------------------------------------------+
+ */
+
+namespace Civi\Api4\Generic;
+
+use Civi\Api4\Utils\CoreUtil;
+
+/**
+ * Retrieve $ENTITIES for an autocomplete form field.
+ *
+ * @method $this setInput(string $input) Set input term.
+ * @method string getInput()
+ * @method $this setIds(array $ids) Set array of ids.
+ * @method array getIds()
+ * @method $this setPage(int $page) Set current page.
+ * @method array getPage()
+ * @method $this setFormName(string $formName) Set formName.
+ * @method string getFormName()
+ * @method $this setFieldName(string $fieldName) Set fieldName.
+ * @method string getFieldName()
+ * @method $this setClientFilters(array $clientFilters) Set array of untrusted filter values.
+ * @method array getClientFilters()
+ */
+class AutocompleteAction extends AbstractAction {
+  use Traits\SavedSearchInspectorTrait;
+
+  /**
+   * Autocomplete search input for search mode
+   *
+   * @var string
+   */
+  protected $input = '';
+
+  /**
+   * Array of ids for render mode
+   *
+   * @var array
+   */
+  protected $ids;
+
+  /**
+   * @var int
+   */
+  protected $page = 1;
+
+  /**
+   * Name of SavedSearch to use for filtering.
+   * @var string
+   */
+  protected $savedSearch;
+
+  /**
+   * @var string
+   */
+  protected $formName;
+
+  /**
+   * @var string
+   */
+  protected $fieldName;
+
+  /**
+   * Filters requested by untrusted client, permissions will be checked before applying (even if this request has checkPermissions = FALSE).
+   *
+   * Format: [fieldName => value][]
+   * @var array
+   */
+  protected $clientFilters = [];
+
+  /**
+   * Filters set programmatically by `civi.api.prepare` listener. Automatically trusted.
+   *
+   * Format: [fieldName => value][]
+   * @var array
+   */
+  private $trustedFilters = [];
+
+  /**
+   * Fetch results.
+   *
+   * @param \Civi\Api4\Generic\Result $result
+   */
+  public function _run(Result $result) {
+    $entityName = $this->getEntityName();
+    $fields = CoreUtil::getApiClass($entityName)::get()->entityFields();
+    $idField = CoreUtil::getIdFieldName($entityName);
+    $labelField = CoreUtil::getInfoItem($entityName, 'label_field');
+    $iconFields = CoreUtil::getInfoItem($entityName, 'icon_field') ?? [];
+    $map = [
+      'id' => $idField,
+      'label' => $labelField,
+    ];
+    // FIXME: Use metadata
+    if (isset($fields['description'])) {
+      $map['description'] = 'description';
+    }
+    if (isset($fields['color'])) {
+      $map['color'] = 'color';
+    }
+    $select = array_merge(array_values($map), $iconFields);
+
+    if (!$this->savedSearch) {
+      $this->savedSearch = ['api_entity' => $entityName];
+    }
+    $this->loadSavedSearch();
+    // Pass-through this parameter
+    $this->_apiParams['checkPermissions'] = $this->savedSearch['api_params']['checkPermissions'] = $this->getCheckPermissions();
+    // Render mode: fetch by id
+    if ($this->ids) {
+      $this->_apiParams['where'][] = [$idField, 'IN', $this->ids];
+      $resultsPerPage = NULL;
+    }
+    // Search mode: fetch a page of results based on input
+    else {
+      $resultsPerPage = \Civi::settings()->get('search_autocomplete_count') ?: 10;
+      // Adding one extra result allows us to see if there are any more
+      $this->_apiParams['limit'] = $resultsPerPage + 1;
+      $this->_apiParams['offset'] = ($this->page - 1) * $resultsPerPage;
+
+      $orderBy = CoreUtil::getInfoItem($this->getEntityName(), 'order_by') ?: $labelField;
+      $this->_apiParams['orderBy'] = [$orderBy => 'ASC'];
+      if (strlen($this->input)) {
+        $prefix = \Civi::settings()->get('includeWildCardInName') ? '%' : '';
+        $this->_apiParams['where'][] = [$labelField, 'LIKE', $prefix . $this->input . '%'];
+      }
+    }
+    if (empty($this->_apiParams['having'])) {
+      $this->_apiParams['select'] = $select;
+    }
+    // A HAVING clause depends on the SELECT clause so don't overwrite it.
+    else {
+      $this->_apiParams['select'] = array_unique(array_merge($this->_apiParams['select'], $select));
+    }
+    $this->applyFilters();
+    $apiResult = civicrm_api4($entityName, 'get', $this->_apiParams);
+    $rawResults = array_slice((array) $apiResult, 0, $resultsPerPage);
+    foreach ($rawResults as $row) {
+      $mapped = [];
+      foreach ($map as $key => $fieldName) {
+        $mapped[$key] = $row[$fieldName];
+      }
+      // Get icon in order of priority
+      foreach ($iconFields as $fieldName) {
+        if (!empty($row[$fieldName])) {
+          // Icon field may be multivalued e.g. contact_sub_type
+          $icon = \CRM_Utils_Array::first(array_filter((array) $row[$fieldName]));
+          if ($icon) {
+            $mapped['icon'] = $icon;
+          }
+          break;
+        }
+      }
+      $result[] = $mapped;
+    }
+    $result->setCountMatched($apiResult->countFetched());
+  }
+
+  /**
+   * Method for `civi.api.prepare` listener to add a trusted filter.
+   *
+   * @param string $fieldName
+   * @param mixed $value
+   */
+  public function addFilter(string $fieldName, $value) {
+    $this->trustedFilters[$fieldName] = $value;
+  }
+
+  /**
+   * Applies trusted filters. Checks access before applying client filters.
+   */
+  private function applyFilters() {
+    foreach ($this->trustedFilters as $field => $val) {
+      if ($this->hasValue($val)) {
+        $this->applyFilter($field, $val);
+      }
+    }
+    foreach ($this->clientFilters as $field => $val) {
+      if ($this->hasValue($val) && $this->checkFieldAccess($field)) {
+        $this->applyFilter($field, $val);
+      }
+    }
+  }
+
+  /**
+   * @param $fieldNameWithSuffix
+   * @return bool
+   */
+  private function checkFieldAccess($fieldNameWithSuffix) {
+    [$fieldName] = explode(':', $fieldNameWithSuffix);
+    if (
+      in_array($fieldName, $this->_apiParams['select'], TRUE) ||
+      in_array($fieldNameWithSuffix, $this->_apiParams['select'], TRUE) ||
+      in_array($fieldName, $this->savedSearch['api_params']['select'], TRUE) ||
+      in_array($fieldNameWithSuffix, $this->savedSearch['api_params']['select'], TRUE)
+    ) {
+      return TRUE;
+    }
+    // Proceed only if permissions are being enforced.'
+    // Anonymous users in permission-bypass mode should not be allowed to set arbitrary filters.
+    if ($this->getCheckPermissions()) {
+      // This function checks field permissions
+      return (bool) $this->getField($fieldName);
+    }
+    return FALSE;
+  }
+
+  /**
+   * @return array
+   */
+  public function getPermissions() {
+    // Permissions for this action are checked internally
+    return [];
+  }
+
+}
diff --git a/Civi/Api4/Generic/BasicEntity.php b/Civi/Api4/Generic/BasicEntity.php
index 066ef04e7a5..87ae77c4436 100644
--- a/Civi/Api4/Generic/BasicEntity.php
+++ b/Civi/Api4/Generic/BasicEntity.php
@@ -136,6 +136,15 @@ public static function replace($checkPermissions = TRUE) {
       ->setCheckPermissions($checkPermissions);
   }
 
+  /**
+   * @param bool $checkPermissions
+   * @return AutocompleteAction
+   */
+  public static function autocomplete($checkPermissions = TRUE) {
+    return (new AutocompleteAction(static::getEntityName(), __FUNCTION__))
+      ->setCheckPermissions($checkPermissions);
+  }
+
   /**
    * @inheritDoc
    */
diff --git a/Civi/Api4/Generic/DAOEntity.php b/Civi/Api4/Generic/DAOEntity.php
index 3bec3919bbd..ea7473e87a9 100644
--- a/Civi/Api4/Generic/DAOEntity.php
+++ b/Civi/Api4/Generic/DAOEntity.php
@@ -90,4 +90,13 @@ public static function replace($checkPermissions = TRUE) {
       ->setCheckPermissions($checkPermissions);
   }
 
+  /**
+   * @param bool $checkPermissions
+   * @return AutocompleteAction
+   */
+  public static function autocomplete($checkPermissions = TRUE) {
+    return (new AutocompleteAction(static::getEntityName(), __FUNCTION__))
+      ->setCheckPermissions($checkPermissions);
+  }
+
 }
diff --git a/ext/search_kit/Civi/Api4/Action/SearchDisplay/SavedSearchInspectorTrait.php b/Civi/Api4/Generic/Traits/SavedSearchInspectorTrait.php
similarity index 58%
rename from ext/search_kit/Civi/Api4/Action/SearchDisplay/SavedSearchInspectorTrait.php
rename to Civi/Api4/Generic/Traits/SavedSearchInspectorTrait.php
index 1f935a46192..0cd0f230a11 100644
--- a/ext/search_kit/Civi/Api4/Action/SearchDisplay/SavedSearchInspectorTrait.php
+++ b/Civi/Api4/Generic/Traits/SavedSearchInspectorTrait.php
@@ -1,6 +1,6 @@
 <?php
 
-namespace Civi\Api4\Action\SearchDisplay;
+namespace Civi\Api4\Generic\Traits;
 
 use Civi\API\Request;
 use Civi\Api4\Query\SqlExpression;
@@ -54,6 +54,10 @@ protected function loadSavedSearch() {
         ->addWhere('name', '=', $this->savedSearch)
         ->execute()->single();
     }
+    if (is_array($this->savedSearch)) {
+      $this->savedSearch += ['api_params' => []];
+      $this->savedSearch['api_params'] += ['version' => 4, 'select' => [], 'where' => []];
+    }
     $this->_apiParams = ($this->savedSearch['api_params'] ?? []) + ['select' => [], 'where' => []];
   }
 
@@ -176,4 +180,103 @@ private function canAggregate($fieldPath) {
     return !in_array($idField, $apiParams['groupBy']);
   }
 
+  /**
+   * @param string|array $fieldName
+   *   If multiple field names are given they will be combined in an OR clause
+   * @param mixed $value
+   */
+  protected function applyFilter($fieldName, $value) {
+    // Global setting determines if % wildcard should be added to both sides (default) or only the end of a search string
+    $prefixWithWildcard = \Civi::settings()->get('includeWildCardInName');
+
+    $fieldNames = (array) $fieldName;
+    // Based on the first field, decide which clause to add this condition to
+    $fieldName = $fieldNames[0];
+    $field = $this->getField($fieldName);
+    // If field is not found it must be an aggregated column & belongs in the HAVING clause.
+    if (!$field) {
+      $this->_apiParams += ['having' => []];
+      $clause =& $this->_apiParams['having'];
+    }
+    // If field belongs to an EXCLUDE join, it should be added as a join condition
+    else {
+      $prefix = strpos($fieldName, '.') ? explode('.', $fieldName)[0] : NULL;
+      foreach ($this->_apiParams['join'] ?? [] as $idx => $join) {
+        if (($join[1] ?? 'LEFT') === 'EXCLUDE' && (explode(' AS ', $join[0])[1] ?? '') === $prefix) {
+          $clause =& $this->_apiParams['join'][$idx];
+        }
+      }
+    }
+    // Default: add filter to WHERE clause
+    if (!isset($clause)) {
+      $clause =& $this->_apiParams['where'];
+    }
+
+    $filterClauses = [];
+
+    foreach ($fieldNames as $fieldName) {
+      $field = $this->getField($fieldName);
+      $dataType = $field['data_type'] ?? NULL;
+      // Array is either associative `OP => VAL` or sequential `IN (...)`
+      if (is_array($value)) {
+        $value = array_filter($value, [$this, 'hasValue']);
+        // If array does not contain operators as keys, assume array of values
+        if (array_diff_key($value, array_flip(CoreUtil::getOperators()))) {
+          // Use IN for regular fields
+          if (empty($field['serialize'])) {
+            $filterClauses[] = [$fieldName, 'IN', $value];
+          }
+          // Use an OR group of CONTAINS for array fields
+          else {
+            $orGroup = [];
+            foreach ($value as $val) {
+              $orGroup[] = [$fieldName, 'CONTAINS', $val];
+            }
+            $filterClauses[] = ['OR', $orGroup];
+          }
+        }
+        // Operator => Value array
+        else {
+          $andGroup = [];
+          foreach ($value as $operator => $val) {
+            $andGroup[] = [$fieldName, $operator, $val];
+          }
+          $filterClauses[] = ['AND', $andGroup];
+        }
+      }
+      elseif (!empty($field['serialize'])) {
+        $filterClauses[] = [$fieldName, 'CONTAINS', $value];
+      }
+      elseif (!empty($field['options']) || in_array($dataType, ['Integer', 'Boolean', 'Date', 'Timestamp'])) {
+        $filterClauses[] = [$fieldName, '=', $value];
+      }
+      elseif ($prefixWithWildcard) {
+        $filterClauses[] = [$fieldName, 'CONTAINS', $value];
+      }
+      else {
+        $filterClauses[] = [$fieldName, 'LIKE', $value . '%'];
+      }
+    }
+    // Single field
+    if (count($filterClauses) === 1) {
+      $clause[] = $filterClauses[0];
+    }
+    else {
+      $clause[] = ['OR', $filterClauses];
+    }
+  }
+
+  /**
+   * Checks if a filter contains a non-empty value
+   *
+   * "Empty" search values are [], '', and NULL.
+   * Also recursively checks arrays to ensure they contain at least one non-empty value.
+   *
+   * @param $value
+   * @return bool
+   */
+  protected function hasValue($value) {
+    return $value !== '' && $value !== NULL && (!is_array($value) || array_filter($value, [$this, 'hasValue']));
+  }
+
 }
diff --git a/Civi/Api4/Service/Spec/SpecFormatter.php b/Civi/Api4/Service/Spec/SpecFormatter.php
index fb0b83a7360..81ac207389f 100644
--- a/Civi/Api4/Service/Spec/SpecFormatter.php
+++ b/Civi/Api4/Service/Spec/SpecFormatter.php
@@ -197,7 +197,6 @@ private static function addOptionProps(&$options, $spec, $baoName, $fieldName, $
     $returnFormat = array_diff($returnFormat, ['id', 'name', 'label']);
     // CRM_Core_Pseudoconstant doesn't know how to fetch extra stuff like icon, description, color, etc., so we have to invent that wheel here...
     if ($returnFormat) {
-      $optionIds = implode(',', array_column($options, 'id'));
       $optionIndex = array_flip(array_column($options, 'id'));
       if ($spec instanceof CustomFieldSpec) {
         $optionGroupId = \CRM_Core_DAO::getFieldValue('CRM_Core_DAO_CustomField', $spec->getCustomFieldId(), 'option_group_id');
@@ -229,15 +228,18 @@ private static function addOptionProps(&$options, $spec, $baoName, $fieldName, $
           $returnFormat = array_diff($returnFormat, ['abbr']);
         }
         // Fetch anything else (color, icon, description)
-        if ($returnFormat && !empty($pseudoconstant['table']) && \CRM_Utils_Rule::commaSeparatedIntegers($optionIds)) {
-          $sql = "SELECT * FROM {$pseudoconstant['table']} WHERE id IN (%1)";
-          $query = \CRM_Core_DAO::executeQuery($sql, [1 => [$optionIds, 'CommaSeparatedIntegers']]);
+        if ($returnFormat && !empty($pseudoconstant['table'])) {
+          $idCol = $pseudoconstant['keyColumn'] ?? 'id';
+          $optionIds = \CRM_Core_DAO::escapeStrings(array_column($options, 'id'));
+          $sql = "SELECT * FROM {$pseudoconstant['table']} WHERE `$idCol` IN ($optionIds)";
+          $query = \CRM_Core_DAO::executeQuery($sql);
           while ($query->fetch()) {
             foreach ($returnFormat as $ret) {
-              if (property_exists($query, $ret)) {
+              $retCol = $pseudoconstant[$ret . 'Column'] ?? $ret;
+              if (property_exists($query, $retCol)) {
                 // Note: our schema is inconsistent about whether `description` fields allow html,
                 // but it's usually assumed to be plain text, so we strip_tags() to standardize it.
-                $options[$optionIndex[$query->id]][$ret] = $ret === 'description' ? strip_tags($query->$ret ?? '') : $query->$ret;
+                $options[$optionIndex[$query->$idCol]][$ret] = isset($query->$retCol) ? strip_tags($query->$retCol) : NULL;
               }
             }
           }
diff --git a/Civi/Api4/Utils/FormattingUtil.php b/Civi/Api4/Utils/FormattingUtil.php
index efacccb3de3..2079d929fe4 100644
--- a/Civi/Api4/Utils/FormattingUtil.php
+++ b/Civi/Api4/Utils/FormattingUtil.php
@@ -211,7 +211,7 @@ public static function formatOutputValues(&$results, $fields, $action = 'get', $
         // Evaluate pseudoconstant suffixes
         $suffix = strrpos(($fieldName ?? ''), ':');
         $fieldOptions = NULL;
-        if ($suffix) {
+        if (isset($value) && $suffix) {
           $fieldOptions = self::getPseudoconstantList($field, $fieldName, $result, $action);
           $dataType = NULL;
         }
diff --git a/ang/crmUi.js b/ang/crmUi.js
index 1e59ef0dbd4..33588accbd8 100644
--- a/ang/crmUi.js
+++ b/ang/crmUi.js
@@ -704,6 +704,32 @@
       };
     })
 
+    // Render a crmAutocomplete APIv4 widget
+    // usage: <input crm-autocomplete="'Contact'" crm-autocomplete-params={savedSearch: 'mySearch', filters: {is_deceased: false}}" ng-model="myobj.field" />
+    .directive('crmAutocomplete', function () {
+      return {
+        require: {
+          ngModel: '?ngModel'
+        },
+        bindToController: {
+          crmAutocomplete: '<',
+          crmAutocompleteParams: '<'
+        },
+        controller: function($element, $timeout) {
+          var ctrl = this;
+          $timeout(function() {
+            $element.crmAutocomplete(ctrl.crmAutocomplete, ctrl.crmAutocompleteParams);
+            // Ensure widget is updated when model changes
+            if (ctrl.ngModel) {
+              ctrl.ngModel.$render = function() {
+                $element.val(ctrl.ngModel.$viewValue || '').change();
+              };
+            }
+          });
+        }
+      };
+    })
+
     // validate multiple email text
     // usage: <input crm-multiple-email type="text" ng-model="myobj.field" />
     .directive('crmMultipleEmail', function ($parse, $timeout) {
diff --git a/ext/afform/admin/Civi/AfformAdmin/AfformAdminMeta.php b/ext/afform/admin/Civi/AfformAdmin/AfformAdminMeta.php
index a0f4b9061c0..469b97dd929 100644
--- a/ext/afform/admin/Civi/AfformAdmin/AfformAdminMeta.php
+++ b/ext/afform/admin/Civi/AfformAdmin/AfformAdminMeta.php
@@ -87,7 +87,7 @@ public static function getFields($entityName, $params = []) {
     $params += [
       'checkPermissions' => FALSE,
       'loadOptions' => ['id', 'label'],
-      'action' => 'create',
+      'action' => 'update',
       'select' => ['name', 'label', 'input_type', 'input_attrs', 'required', 'options', 'help_pre', 'help_post', 'serialize', 'data_type', 'fk_entity', 'readonly'],
       'where' => [['input_type', 'IS NOT NULL']],
     ];
@@ -123,8 +123,14 @@ public static function getFields($entityName, $params = []) {
     }
     // Index by name
     $fields = array_column($fields, NULL, 'name');
-    // Mix in alterations declared by afform entities
-    if ($params['action'] === 'create') {
+    if ($params['action'] === 'update') {
+      // Add existing entity field
+      $idField = CoreUtil::getIdFieldName($entityName);
+      $fields[$idField]['readonly'] = FALSE;
+      $fields[$idField]['input_type'] = 'Existing';
+      $fields[$idField]['is_id'] = TRUE;
+      $fields[$idField]['label'] = E::ts('Existing %1', [1 => CoreUtil::getInfoItem($entityName, 'title')]);
+      // Mix in alterations declared by afform entities
       $afEntity = self::getMetadata()['entities'][$entityName] ?? [];
       if (!empty($afEntity['alterFields'])) {
         foreach ($afEntity['alterFields'] as $fieldName => $changes) {
diff --git a/ext/afform/admin/Civi/Api4/Action/Afform/LoadAdminData.php b/ext/afform/admin/Civi/Api4/Action/Afform/LoadAdminData.php
index db70363cdce..1bcba815522 100644
--- a/ext/afform/admin/Civi/Api4/Action/Afform/LoadAdminData.php
+++ b/ext/afform/admin/Civi/Api4/Action/Afform/LoadAdminData.php
@@ -83,7 +83,7 @@ public function _run(\Civi\Api4\Generic\Result $result) {
       }
     }
 
-    $getFieldsMode = 'create';
+    $getFieldsMode = 'update';
 
     // Generate list of possibly embedded afform tags to search for
     $allAfforms = \Civi::service('afform_scanner')->findFilePaths();
diff --git a/ext/afform/admin/ang/afGuiEditor/elements/afGuiField-menu.html b/ext/afform/admin/ang/afGuiEditor/elements/afGuiField-menu.html
index 85de8d309f5..6896abf1b20 100644
--- a/ext/afform/admin/ang/afGuiEditor/elements/afGuiField-menu.html
+++ b/ext/afform/admin/ang/afGuiEditor/elements/afGuiField-menu.html
@@ -1,4 +1,4 @@
-<li>
+<li ng-if="$ctrl.fieldDefn.input_type !== 'Existing'">
   <div href ng-click="$event.stopPropagation()" class="af-gui-field-select-in-dropdown">
     <label>{{:: ts('Type:') }}</label>
     <select class="form-control" ng-model="getSet('input_type')" ng-model-options="{getterSetter: true}" title="{{:: ts('Field type') }}">
@@ -6,19 +6,25 @@
     </select>
   </div>
 </li>
+<li ng-if="$ctrl.fieldDefn.input_type === 'Existing'" title="{{:: ts('Use a saved search to filter the autocomplete results') }}">
+  <div href ng-click="$event.stopPropagation()" class="af-gui-field-select-in-dropdown">
+    <label>{{:: ts('Saved Search:') }}</label>
+    <input class="form-control" crm-entityref="{entity: 'SavedSearch', api: {id_field: 'name', params: {api_entity: $ctrl.getEntity().name}}}" ng-model="getSet('saved_search')" ng-model-options="{getterSetter: true}">
+  </div>
+</li>
 <li>
   <a href ng-click="toggleRequired(); $event.stopPropagation(); $event.target.blur();" title="{{:: ts('Require this field') }}">
     <i class="crm-i fa-{{ getProp('required') ? 'check-' : '' }}square-o"></i>
     {{:: ts('Required') }}
   </a>
 </li>
-<li>
+<li ng-if="$ctrl.fieldDefn.input_type !== 'Existing'">
   <a href ng-click="toggleDefaultValue(); $event.stopPropagation(); $event.target.blur();" title="{{:: ts('Pre-fill this field with a value') }}">
     <i class="crm-i fa-{{ $ctrl.hasDefaultValue ? 'check-' : '' }}square-o"></i>
     {{:: ts('Default value') }}
   </a>
 </li>
-<li ng-if="$ctrl.hasDefaultValue">
+<li ng-if="$ctrl.fieldDefn.input_type !== 'Existing' && $ctrl.hasDefaultValue">
   <div ng-click="$event.stopPropagation()" class="af-gui-field-select-in-dropdown form-inline">
     <input class="form-control" af-gui-field-value="$ctrl.fieldDefn" ng-model="getSet('afform_default')" ng-model-options="{getterSetter: true}" >
   </div>
diff --git a/ext/afform/admin/ang/afGuiEditor/elements/afGuiField.component.js b/ext/afform/admin/ang/afGuiEditor/elements/afGuiField.component.js
index 0102c32e9bf..177e9b1700d 100644
--- a/ext/afform/admin/ang/afGuiEditor/elements/afGuiField.component.js
+++ b/ext/afform/admin/ang/afGuiEditor/elements/afGuiField.component.js
@@ -52,7 +52,8 @@
       };
 
       this.getFkEntity = function() {
-        var fkEntity = ctrl.getDefn().fk_entity;
+        var defn = ctrl.getDefn(),
+          fkEntity = defn.is_id ? ctrl.container.getMainEntityType() : defn.fk_entity;
         return ctrl.editor.meta.entities[fkEntity];
       };
 
@@ -99,11 +100,18 @@
         return defn;
       };
 
+      // Get the api entity this field belongs to
+      this.getEntity = function() {
+        return afGui.getEntity(ctrl.container.getFieldEntityType(ctrl.node.name));
+      };
+
       $scope.getOriginalLabel = function() {
+        // Use afform entity if available (e.g. "Individual1")
         if (ctrl.container.getEntityName()) {
           return ctrl.editor.getEntity(ctrl.container.getEntityName()).label + ': ' + ctrl.getDefn().label;
         }
-        return afGui.getEntity(ctrl.container.getFieldEntityType(ctrl.node.name)).label + ': ' + ctrl.getDefn().label;
+        // Use generic entity (e.g. "Contact")
+        return ctrl.getEntity().label + ': ' + ctrl.getDefn().label;
       };
 
       $scope.hasOptions = function() {
diff --git a/ext/afform/admin/ang/afGuiEditor/inputType/Existing.html b/ext/afform/admin/ang/afGuiEditor/inputType/Existing.html
new file mode 100644
index 00000000000..d2538363fd3
--- /dev/null
+++ b/ext/afform/admin/ang/afGuiEditor/inputType/Existing.html
@@ -0,0 +1,8 @@
+<div class="form-inline">
+  <div class="input-group">
+    <input autocomplete="off" type="text" class="form-control" placeholder="{{:: ts('Select %1', {1: $ctrl.getFkEntity().label}) }}" title="{{:: ts('Click to add placeholder text') }}" ng-model="getSet('input_attrs.placeholder')" ng-model-options="$ctrl.editor.debounceWithGetterSetter">
+    <div class="input-group-btn">
+      <button type="button" class="btn btn-default" disabled><i class="crm-i fa-search"></i></button>
+    </div>
+  </div>
+</div>
diff --git a/ext/afform/core/Civi/Afform/AfformMetadataInjector.php b/ext/afform/core/Civi/Afform/AfformMetadataInjector.php
index ca20b3ac78f..b84bdfb324c 100644
--- a/ext/afform/core/Civi/Afform/AfformMetadataInjector.php
+++ b/ext/afform/core/Civi/Afform/AfformMetadataInjector.php
@@ -11,6 +11,7 @@
 
 namespace Civi\Afform;
 
+use Civi\Api4\Utils\CoreUtil;
 use CRM_Afform_ExtensionUtil as E;
 
 /**
@@ -41,7 +42,7 @@ public static function preprocess($e) {
         // Each field can be nested within a fieldset, a join or a block
         foreach (pq('af-field', $doc) as $afField) {
           /** @var \DOMElement $afField */
-          $action = 'create';
+          $action = 'update';
           $joinName = pq($afField)->parents('[af-join]')->attr('af-join');
           if ($joinName) {
             self::fillFieldMetadata($joinName, $action, $afField);
@@ -178,6 +179,14 @@ private static function getField(string $entityName, string $fieldName, string $
         break;
       }
     }
+    // Id field for selecting existing entity
+    if ($action === 'update' && $field['name'] === CoreUtil::getIdFieldName($entityName)) {
+      $entityTitle = CoreUtil::getInfoItem($entityName, 'title');
+      $field['input_type'] = 'Existing';
+      $field['entity'] = $entityName;
+      $field['label'] = E::ts('Existing %1', [1 => $entityTitle]);
+      $field['input_attrs']['placeholder'] = E::ts('Select %1', [1 => $entityTitle]);
+    }
     // If this is an implicit join, get new field from fk entity
     if ($field['name'] !== $fieldName && $field['fk_entity']) {
       $params['where'] = [['name', '=', substr($fieldName, 1 + strrpos($fieldName, '.'))]];
diff --git a/ext/afform/core/Civi/Afform/FormDataModel.php b/ext/afform/core/Civi/Afform/FormDataModel.php
index a3687282626..8d99733f8cd 100644
--- a/ext/afform/core/Civi/Afform/FormDataModel.php
+++ b/ext/afform/core/Civi/Afform/FormDataModel.php
@@ -50,7 +50,7 @@ public function __construct($layout) {
       $this->entities[$entity]['fields'] = $this->entities[$entity]['joins'] = [];
     }
     // Pre-load full list of afforms in case this layout embeds other afform directives
-    $this->blocks = (array) Afform::get()->setCheckPermissions(FALSE)->setSelect(['name', 'directive_name'])->execute()->indexBy('directive_name');
+    $this->blocks = (array) Afform::get(FALSE)->setSelect(['name', 'directive_name'])->execute()->indexBy('directive_name');
     $this->parseFields($layout);
   }
 
@@ -171,7 +171,7 @@ protected function parseFields($nodes, $entity = NULL, $join = NULL, $searchDisp
       // Recurse into embedded blocks
       if (isset($this->blocks[$node['#tag']])) {
         if (!isset($this->blocks[$node['#tag']]['layout'])) {
-          $this->blocks[$node['#tag']] = Afform::get()->setCheckPermissions(FALSE)->setSelect(['name', 'layout'])->addWhere('name', '=', $this->blocks[$node['#tag']]['name'])->execute()->first();
+          $this->blocks[$node['#tag']] = Afform::get(FALSE)->setSelect(['name', 'layout'])->addWhere('name', '=', $this->blocks[$node['#tag']]['name'])->execute()->first();
         }
         if (!empty($this->blocks[$node['#tag']]['layout'])) {
           $this->parseFields($this->blocks[$node['#tag']]['layout'], $entity, $join, $searchDisplay);
diff --git a/ext/afform/core/Civi/Api4/Action/Afform/AbstractProcessor.php b/ext/afform/core/Civi/Api4/Action/Afform/AbstractProcessor.php
index 870254d1c16..fb58a574da7 100644
--- a/ext/afform/core/Civi/Api4/Action/Afform/AbstractProcessor.php
+++ b/ext/afform/core/Civi/Api4/Action/Afform/AbstractProcessor.php
@@ -9,6 +9,9 @@
 /**
  * Shared functionality for form submission pre & post processing.
  * @package Civi\Api4\Action\Afform
+ *
+ * @method $this setFillMode(string $fillMode) Set entity/form fill mode.
+ * @method string getFillMode()
  */
 abstract class AbstractProcessor extends \Civi\Api4\Generic\AbstractAction {
 
@@ -25,6 +28,13 @@ abstract class AbstractProcessor extends \Civi\Api4\Generic\AbstractAction {
    */
   protected $args = [];
 
+  /**
+   * Used by prefill action to indicate if the entire form or just one entity is being filled.
+   * @var string
+   * @options form,entity
+   */
+  protected $fillMode = 'form';
+
   /**
    * @var array
    */
@@ -68,14 +78,18 @@ public function _run(Result $result) {
   protected function loadEntities() {
     foreach ($this->_formDataModel->getEntities() as $entityName => $entity) {
       $this->_entityIds[$entityName] = [];
+      $idField = CoreUtil::getIdFieldName($entity['type']);
       if (!empty($entity['actions']['update'])) {
-        if (!empty($this->args[$entityName]) && !empty($entity['url-autofill'])) {
-          $ids = array_map('trim', explode(',', $this->args[$entityName]));
+        if (
+          !empty($this->args[$entityName]) &&
+          (!empty($entity['url-autofill']) || isset($entity['fields'][$idField]))
+        ) {
+          $ids = (array) $this->args[$entityName];
           // Limit number of records to 1 unless using af-repeat
           $ids = array_slice($ids, 0, !empty($entity['af-repeat']) ? $entity['max'] ?? NULL : 1);
           $this->loadEntity($entity, $ids);
         }
-        elseif (!empty($entity['autofill'])) {
+        elseif (!empty($entity['autofill']) && $this->fillMode !== 'entity') {
           $this->autofillEntity($entity, $entity['autofill']);
         }
       }
@@ -90,10 +104,17 @@ protected function loadEntities() {
    */
   private function loadEntity(array $entity, array $ids) {
     $api4 = $this->_formDataModel->getSecureApi4($entity['name']);
+    $idField = CoreUtil::getIdFieldName($entity['type']);
+    if (!empty($entity['fields'][$idField]['saved_search'])) {
+      $ids = $this->validateBySavedSearch($entity, $idField, $ids);
+    }
+    if (!$ids) {
+      return;
+    }
     $result = $api4($entity['type'], 'get', [
       'where' => [['id', 'IN', $ids]],
       'select' => array_keys($entity['fields']),
-    ])->indexBy('id');
+    ])->indexBy($idField);
     foreach ($ids as $index => $id) {
       $this->_entityIds[$entity['name']][$index] = [
         'id' => isset($result[$id]) ? $id : NULL,
@@ -133,6 +154,23 @@ private function autoFillEntity($entity, $mode) {
     }
   }
 
+  private function validateBySavedSearch($entity, array $ids) {
+    $idField = CoreUtil::getIdFieldName($entity['type']);
+    $fetched = civicrm_api4($entity['type'], 'autocomplete', [
+      'ids' => $ids,
+      'formName' => 'afform:' . $this->name,
+      'fieldName' => $entity['name'] . ':' . $idField,
+    ])->indexBy($idField);
+    $validIds = [];
+    // Preserve keys
+    foreach ($ids as $index => $id) {
+      if (isset($fetched[$id])) {
+        $validIds[$index] = $id;
+      }
+    }
+    return $validIds;
+  }
+
   /**
    * @return array
    */
diff --git a/ext/afform/core/Civi/Api4/Afform.php b/ext/afform/core/Civi/Api4/Afform.php
index 0f71813b784..8da02bd89d2 100644
--- a/ext/afform/core/Civi/Api4/Afform.php
+++ b/ext/afform/core/Civi/Api4/Afform.php
@@ -2,6 +2,7 @@
 
 namespace Civi\Api4;
 
+use Civi\Api4\Generic\AutocompleteAction;
 use Civi\Api4\Generic\BasicGetFieldsAction;
 
 /**
@@ -16,6 +17,8 @@
  *      The `prefill` and `submit` actions are used for preparing forms and processing submissions.
  *
  * @see https://lab.civicrm.org/extensions/afform
+ * @labelField title
+ * @iconField type:icon
  * @searchable none
  * @package Civi\Api4
  */
@@ -57,6 +60,15 @@ public static function save($checkPermissions = TRUE) {
       ->setCheckPermissions($checkPermissions);
   }
 
+  /**
+   * @param bool $checkPermissions
+   * @return \Civi\Api4\Generic\AutocompleteAction
+   */
+  public static function autocomplete($checkPermissions = TRUE) {
+    return (new AutocompleteAction('Afform', __FUNCTION__))
+      ->setCheckPermissions($checkPermissions);
+  }
+
   /**
    * @param bool $checkPermissions
    * @return Action\Afform\Convert
diff --git a/ext/afform/core/Civi/Api4/Subscriber/AutocompleteSubscriber.php b/ext/afform/core/Civi/Api4/Subscriber/AutocompleteSubscriber.php
new file mode 100644
index 00000000000..685a99c95d9
--- /dev/null
+++ b/ext/afform/core/Civi/Api4/Subscriber/AutocompleteSubscriber.php
@@ -0,0 +1,77 @@
+<?php
+/*
+ +--------------------------------------------------------------------+
+ | Copyright CiviCRM LLC. All rights reserved.                        |
+ |                                                                    |
+ | This work is published under the GNU AGPLv3 license with some      |
+ | permitted exceptions and without any warranty. For full license    |
+ | and copyright information, see https://civicrm.org/licensing       |
+ +--------------------------------------------------------------------+
+ */
+
+namespace Civi\Api4\Subscriber;
+
+use Civi\Afform\FormDataModel;
+use Civi\API\Events;
+use Civi\Api4\Afform;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+
+/**
+ * Preprocess api autocomplete requests
+ */
+class AutocompleteSubscriber implements EventSubscriberInterface {
+
+  /**
+   * @return array
+   */
+  public static function getSubscribedEvents() {
+    return [
+      'civi.api.prepare' => ['onApiPrepare', Events::W_MIDDLE],
+    ];
+  }
+
+  /**
+   * @param \Civi\API\Event\PrepareEvent $event
+   *   API preparation event.
+   */
+  public function onApiPrepare(\Civi\API\Event\PrepareEvent $event) {
+    $apiRequest = $event->getApiRequest();
+    if (is_object($apiRequest) && is_a($apiRequest, 'Civi\Api4\Generic\AutocompleteAction')) {
+      $formName = $apiRequest->getFormName();
+      if (!str_starts_with((string) $formName, 'afform:') || !strpos((string) $apiRequest->getFieldName(), ':')) {
+        return;
+      }
+      [$entityName, $fieldName] = explode(':', $apiRequest->getFieldName());
+      // Load afform only if user has permission
+      $afform = Afform::get()
+        ->addWhere('name', '=', str_replace('afform:', '', $formName))
+        ->addSelect('layout')
+        ->execute()->first();
+      if (!$afform) {
+        return;
+      }
+      $formDataModel = new FormDataModel($afform['layout']);
+      $entity = $formDataModel->getEntity($entityName);
+
+      // Look up the "type" fields (e.g. contact_type, activity_type_id, case_type_id, etc)
+      $typeFields = [];
+      if ($entity['type'] === 'Contact') {
+        $typeFields = ['contact_type', 'contact_sub_type'];
+      }
+      else {
+        $extends = array_column(\CRM_Core_BAO_CustomGroup::getCustomGroupExtendsOptions(), 'grouping', 'id');
+        $typeFields = (array) ($extends[$entity['type']] ?? NULL);
+      }
+      // If entity has a type set in the values, auto-apply that to filters
+      foreach ($typeFields as $typeField) {
+        if (!empty($entity['data'][$typeField])) {
+          $apiRequest->addFilter($typeField, $entity['data'][$typeField]);
+        }
+      }
+
+      $apiRequest->setCheckPermissions($entity['security'] !== 'FBAC');
+      $apiRequest->setSavedSearch($entity['fields'][$fieldName]['defn']['saved_search'] ?? NULL);
+    }
+  }
+
+}
diff --git a/ext/afform/core/afform.php b/ext/afform/core/afform.php
index a0b1100347e..711f1a43be0 100644
--- a/ext/afform/core/afform.php
+++ b/ext/afform/core/afform.php
@@ -56,6 +56,7 @@ function afform_civicrm_config(&$config) {
   $dispatcher->addListener('hook_civicrm_alterAngular', ['\Civi\Afform\AfformMetadataInjector', 'preprocess']);
   $dispatcher->addListener('hook_civicrm_check', ['\Civi\Afform\StatusChecks', 'hook_civicrm_check']);
   $dispatcher->addListener('civi.afform.get', ['\Civi\Api4\Action\Afform\Get', 'getCustomGroupBlocks']);
+  $dispatcher->addSubscriber(new \Civi\Api4\Subscriber\AutocompleteSubscriber());
 
   // Register support for email tokens
   if (CRM_Extension_System::singleton()->getMapper()->isActiveModule('authx')) {
@@ -526,6 +527,11 @@ function afform_civicrm_alterApiRoutePermissions(&$permissions, $entity, $action
       $permissions = CRM_Core_Permission::ALWAYS_ALLOW_PERMISSION;
     }
   }
+  // This is temporarily stuck here, but probably belongs in core (until this hook is finally abolished)
+  elseif ($action === 'autocomplete') {
+    // Autocomplete widget must be accessible by anonymous users. Permissions are checked internally.
+    $permissions = CRM_Core_Permission::ALWAYS_ALLOW_PERMISSION;
+  }
 }
 
 /**
diff --git a/ext/afform/core/ang/af/afEntity.component.js b/ext/afform/core/ang/af/afEntity.component.js
index 6f0fef14d2c..c778856ff28 100644
--- a/ext/afform/core/ang/af/afEntity.component.js
+++ b/ext/afform/core/ang/af/afEntity.component.js
@@ -4,6 +4,7 @@
   var modelProps = {
     type: '@',
     data: '=',
+    actions: '=',
     modelName: '@name',
     label: '@',
     autofill: '@'
@@ -16,6 +17,7 @@
 
       this.$onInit = function() {
         var entity = _.pick(this, _.keys(modelProps));
+        entity.actions = entity.actions || {update: true, create: true};
         entity.id = null;
         this.afForm.registerEntity(entity);
       };
diff --git a/ext/afform/core/ang/af/afField.component.js b/ext/afform/core/ang/af/afField.component.js
index aa83eac8fba..63d0021f247 100644
--- a/ext/afform/core/ang/af/afField.component.js
+++ b/ext/afform/core/ang/af/afField.component.js
@@ -169,6 +169,14 @@
         }
       };
 
+      // ngChange callback from Existing entity field
+      ctrl.onSelectExisting = function() {
+        var val = $scope.getSetSelect();
+        var entity = ctrl.afFieldset.modelName;
+        var index = ctrl.getEntityIndex();
+        ctrl.afFieldset.afFormCtrl.loadData(entity, index, val);
+      };
+
       // Params for the Afform.submitFile API when uploading a file field
       ctrl.getFileUploadParams = function() {
         return {
diff --git a/ext/afform/core/ang/af/afFieldset.directive.js b/ext/afform/core/ang/af/afFieldset.directive.js
index 384fad9b90f..d67216de050 100644
--- a/ext/afform/core/ang/af/afFieldset.directive.js
+++ b/ext/afform/core/ang/af/afFieldset.directive.js
@@ -24,6 +24,9 @@
             // If there is no Afform entity, get the name of embedded search display
             $element.find('[search-name][display-name]').attr('display-name');
         };
+        this.getEntity = function() {
+          return this.afFormCtrl.getEntity(this.modelName);
+        };
         this.getEntityType = function() {
           return this.afFormCtrl.getEntity(this.modelName).type;
         };
diff --git a/ext/afform/core/ang/af/afForm.component.js b/ext/afform/core/ang/af/afForm.component.js
index 79514948a47..dbaa9c91049 100644
--- a/ext/afform/core/ang/af/afForm.component.js
+++ b/ext/afform/core/ang/af/afForm.component.js
@@ -37,16 +37,33 @@
       this.getFormMeta = function getFormMeta() {
         return $scope.$parent.meta;
       };
-      this.loadData = function() {
-        var toLoad = 0;
-        args = _.assign({}, $scope.$parent.routeParams || {}, $scope.$parent.options || {});
-        _.each(schema, function(entity, entityName) {
-          if (args[entityName] || entity.autofill) {
-            toLoad++;
-          }
-        });
+      // With no arguments this will prefill the entire form based on url args
+      // With selectedEntity, selectedIndex & selectedId provided this will prefill a single entity
+      this.loadData = function(selectedEntity, selectedIndex, selectedId) {
+        var toLoad = 0,
+          params = {name: ctrl.getFormMeta().name, args: {}};
+        // Load single entity
+        if (selectedEntity) {
+          toLoad = selectedId;
+          params.fillMode = 'entity';
+          params.args[selectedEntity] = {};
+          params.args[selectedEntity][selectedIndex] = selectedId;
+        }
+        // Prefill entire form
+        else {
+          args = _.assign({}, $scope.$parent.routeParams || {}, $scope.$parent.options || {});
+          _.each(schema, function (entity, entityName) {
+            if (args[entityName] || entity.autofill) {
+              toLoad++;
+            }
+            if (args[entityName] && typeof args[entityName] === 'string') {
+              args[entityName] = args[entityName].split(',');
+            }
+          });
+          params.args = args;
+        }
         if (toLoad) {
-          crmApi4('Afform', 'prefill', {name: ctrl.getFormMeta().name, args: args})
+          crmApi4('Afform', 'prefill', params)
             .then(function(result) {
               _.each(result, function(item) {
                 data[item.name] = data[item.name] || {};
@@ -54,6 +71,13 @@
               });
             });
         }
+        // Clear existing contact selection
+        else if (selectedEntity) {
+          data[selectedEntity][selectedIndex].fields = {};
+          if (data[selectedEntity][selectedIndex].joins) {
+            data[selectedEntity][selectedIndex].joins = {};
+          }
+        }
       };
 
       // Used when submitting file fields
@@ -98,7 +122,6 @@
       function replaceTokens(str, vars) {
         function recurse(stack, values) {
           _.each(values, function(value, key) {
-            console.log('value:' + value, stack);
             if (_.isArray(value) || _.isPlainObject(value)) {
               recurse(stack.concat([key]), value);
             } else {
diff --git a/ext/afform/core/ang/af/fields/Existing.html b/ext/afform/core/ang/af/fields/Existing.html
new file mode 100644
index 00000000000..7824c6dfdc2
--- /dev/null
+++ b/ext/afform/core/ang/af/fields/Existing.html
@@ -0,0 +1,9 @@
+<input id="{{:: fieldId }}"
+       class="form-control"
+       ng-disabled="$ctrl.afFieldset.getEntity().actions.update === false"
+       ng-model="getSetSelect"
+       ng-model-options="{getterSetter: true}"
+       crm-autocomplete="$ctrl.defn.entity"
+       crm-autocomplete-params="{formName: 'afform:' + $ctrl.afFieldset.getFormName(), fieldName: $ctrl.afFieldset.modelName + ':' + $ctrl.fieldName}"
+       placeholder="{{:: $ctrl.defn.input_attrs.placeholder }}"
+       ng-change="$ctrl.onSelectExisting()" >
diff --git a/ext/search_kit/Civi/Api4/Action/SearchDisplay/AbstractRunAction.php b/ext/search_kit/Civi/Api4/Action/SearchDisplay/AbstractRunAction.php
index 5df9ef6d1ef..69526ce04fa 100644
--- a/ext/search_kit/Civi/Api4/Action/SearchDisplay/AbstractRunAction.php
+++ b/ext/search_kit/Civi/Api4/Action/SearchDisplay/AbstractRunAction.php
@@ -3,7 +3,6 @@
 namespace Civi\Api4\Action\SearchDisplay;
 
 use Civi\API\Exception\UnauthorizedException;
-use Civi\Api4\Generic\Traits\ArrayQueryActionTrait;
 use Civi\Api4\Query\SqlField;
 use Civi\Api4\SearchDisplay;
 use Civi\Api4\Utils\CoreUtil;
@@ -26,8 +25,8 @@
  */
 abstract class AbstractRunAction extends \Civi\Api4\Generic\AbstractAction {
 
-  use SavedSearchInspectorTrait;
-  use ArrayQueryActionTrait;
+  use \Civi\Api4\Generic\Traits\SavedSearchInspectorTrait;
+  use \Civi\Api4\Generic\Traits\ArrayQueryActionTrait;
 
   /**
    * Either the name of the display or an array containing the display definition (for preview mode)
@@ -828,91 +827,6 @@ protected function getSelectAliases() {
     return $result;
   }
 
-  /**
-   * @param array $fieldNames
-   *   If multiple field names are given they will be combined in an OR clause
-   * @param mixed $value
-   */
-  private function applyFilter(array $fieldNames, $value) {
-    // Global setting determines if % wildcard should be added to both sides (default) or only the end of a search string
-    $prefixWithWildcard = \Civi::settings()->get('includeWildCardInName');
-
-    // Based on the first field, decide which clause to add this condition to
-    $fieldName = $fieldNames[0];
-    $field = $this->getField($fieldName);
-    // If field is not found it must be an aggregated column & belongs in the HAVING clause.
-    if (!$field) {
-      $this->_apiParams += ['having' => []];
-      $clause =& $this->_apiParams['having'];
-    }
-    // If field belongs to an EXCLUDE join, it should be added as a join condition
-    else {
-      $prefix = strpos($fieldName, '.') ? explode('.', $fieldName)[0] : NULL;
-      foreach ($this->_apiParams['join'] ?? [] as $idx => $join) {
-        if (($join[1] ?? 'LEFT') === 'EXCLUDE' && (explode(' AS ', $join[0])[1] ?? '') === $prefix) {
-          $clause =& $this->_apiParams['join'][$idx];
-        }
-      }
-    }
-    // Default: add filter to WHERE clause
-    if (!isset($clause)) {
-      $clause =& $this->_apiParams['where'];
-    }
-
-    $filterClauses = [];
-
-    foreach ($fieldNames as $fieldName) {
-      $field = $this->getField($fieldName);
-      $dataType = $field['data_type'] ?? NULL;
-      // Array is either associative `OP => VAL` or sequential `IN (...)`
-      if (is_array($value)) {
-        $value = array_filter($value, [$this, 'hasValue']);
-        // If array does not contain operators as keys, assume array of values
-        if (array_diff_key($value, array_flip(CoreUtil::getOperators()))) {
-          // Use IN for regular fields
-          if (empty($field['serialize'])) {
-            $filterClauses[] = [$fieldName, 'IN', $value];
-          }
-          // Use an OR group of CONTAINS for array fields
-          else {
-            $orGroup = [];
-            foreach ($value as $val) {
-              $orGroup[] = [$fieldName, 'CONTAINS', $val];
-            }
-            $filterClauses[] = ['OR', $orGroup];
-          }
-        }
-        // Operator => Value array
-        else {
-          $andGroup = [];
-          foreach ($value as $operator => $val) {
-            $andGroup[] = [$fieldName, $operator, $val];
-          }
-          $filterClauses[] = ['AND', $andGroup];
-        }
-      }
-      elseif (!empty($field['serialize'])) {
-        $filterClauses[] = [$fieldName, 'CONTAINS', $value];
-      }
-      elseif (!empty($field['options']) || in_array($dataType, ['Integer', 'Boolean', 'Date', 'Timestamp'])) {
-        $filterClauses[] = [$fieldName, '=', $value];
-      }
-      elseif ($prefixWithWildcard) {
-        $filterClauses[] = [$fieldName, 'CONTAINS', $value];
-      }
-      else {
-        $filterClauses[] = [$fieldName, 'LIKE', $value . '%'];
-      }
-    }
-    // Single field
-    if (count($filterClauses) === 1) {
-      $clause[] = $filterClauses[0];
-    }
-    else {
-      $clause[] = ['OR', $filterClauses];
-    }
-  }
-
   /**
    * Transforms the SORT param (which is expected to be an array of arrays)
    * to the ORDER BY clause (which is an associative array of [field => DIR]
@@ -1047,19 +961,6 @@ protected function getJoinFromAlias(string $alias) {
     return $result ?: $alias;
   }
 
-  /**
-   * Checks if a filter contains a non-empty value
-   *
-   * "Empty" search values are [], '', and NULL.
-   * Also recursively checks arrays to ensure they contain at least one non-empty value.
-   *
-   * @param $value
-   * @return bool
-   */
-  private function hasValue($value) {
-    return $value !== '' && $value !== NULL && (!is_array($value) || array_filter($value, [$this, 'hasValue']));
-  }
-
   /**
    * Returns a list of afform fields used as search filters
    *
diff --git a/ext/search_kit/Civi/Api4/Action/SearchDisplay/GetDefault.php b/ext/search_kit/Civi/Api4/Action/SearchDisplay/GetDefault.php
index 56dc8967b97..2f387cfce7b 100644
--- a/ext/search_kit/Civi/Api4/Action/SearchDisplay/GetDefault.php
+++ b/ext/search_kit/Civi/Api4/Action/SearchDisplay/GetDefault.php
@@ -2,6 +2,7 @@
 
 namespace Civi\Api4\Action\SearchDisplay;
 
+use Civi\Api4\Generic\Traits\SavedSearchInspectorTrait;
 use Civi\Api4\SavedSearch;
 use Civi\Api4\Utils\FormattingUtil;
 use Civi\Search\Display;
diff --git a/js/Common.js b/js/Common.js
index 07eb96b84ad..1c8d621b3f3 100644
--- a/js/Common.js
+++ b/js/Common.js
@@ -523,6 +523,47 @@ if (!CRM.vars) CRM.vars = {};
     });
   };
 
+  // Autocomplete based on APIv4 and Select2.
+  $.fn.crmAutocomplete = function(entityName, apiParams, select2Options) {
+    select2Options = select2Options || {};
+    return $(this).each(function() {
+      $(this).crmSelect2({
+        ajax: {
+          quietMillis: 250,
+          url: CRM.url('civicrm/ajax/api4/' + entityName + '/autocomplete'),
+          data: function (input, pageNum) {
+            return {params: JSON.stringify(_.assign({
+              input: input,
+              page: pageNum || 1
+            }, apiParams))};
+          },
+          results: function(data) {
+            return {
+              results: data.values,
+              more: data.count > data.countFetched
+            };
+          },
+        },
+        minimumInputLength: 1,
+        formatResult: CRM.utils.formatSelect2Result,
+        formatSelection: formatEntityRefSelection,
+        escapeMarkup: _.identity,
+        initSelection: function($el, callback) {
+          var
+            multiple = !!select2Options.multiple,
+            val = $el.val();
+          if (val === '') {
+            return;
+          }
+          var params = $.extend({}, apiParams || {}, {ids: val.split(',')});
+          CRM.api4(entityName, 'autocomplete', params).then(function(result) {
+            callback(multiple ? result : result[0]);
+          });
+        }
+      });
+    });
+  };
+
   /**
    * @see CRM_Core_Form::addEntityRef for docs
    * @param options object
diff --git a/xml/schema/Contact/Contact.xml b/xml/schema/Contact/Contact.xml
index 4b9c1019fdc..69b694642c8 100644
--- a/xml/schema/Contact/Contact.xml
+++ b/xml/schema/Contact/Contact.xml
@@ -44,6 +44,7 @@
       <table>civicrm_contact_type</table>
       <keyColumn>name</keyColumn>
       <labelColumn>label</labelColumn>
+      <iconColumn>icon</iconColumn>
       <condition>parent_id IS NULL</condition>
     </pseudoconstant>
     <html>
@@ -72,6 +73,7 @@
       <table>civicrm_contact_type</table>
       <keyColumn>name</keyColumn>
       <labelColumn>label</labelColumn>
+      <iconColumn>icon</iconColumn>
       <condition>parent_id IS NOT NULL</condition>
     </pseudoconstant>
     <html>
